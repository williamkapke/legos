<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LEGO Set Inventory</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #f5f5f5;
        color: #333;
      }
      .layout {
        display: grid;
        grid-template-columns: 280px 1fr;
        height: 100vh;
      }

      /* Sidebar */
      .sidebar {
        background: #fff;
        border-right: 1px solid #e0e0e0;
        overflow-y: auto;
      }
      .sidebar-header {
        padding: 20px;
        border-bottom: 1px solid #e0e0e0;
        position: sticky;
        top: 0;
        background: #fff;
        z-index: 10;
      }
      .sidebar-header h1 {
        font-size: 18px;
        font-weight: 600;
        color: #333;
      }
      .set-list {
        list-style: none;
      }
      .set-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        transition: background 0.2s;
      }
      .set-item:hover {
        background: #f5f5f5;
      }
      .set-item.active {
        background: #e3f2fd;
        border-left: 3px solid #2196f3;
      }
      .set-item img {
        width: 50px;
        height: 50px;
        object-fit: contain;
        border-radius: 4px;
        background: #f5f5f5;
      }
      .set-item-info h3 {
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 2px;
      }
      .set-item-info span {
        font-size: 12px;
        color: #888;
      }

      /* Main Content */
      .main {
        overflow-y: auto;
        padding: 30px;
      }
      .main-header {
        margin-bottom: 24px;
        display: flex;
        align-items: center;
        gap: 20px;
      }
      .main-header img {
        width: 100px;
        height: 100px;
        object-fit: contain;
        border-radius: 8px;
        background: #fff;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      }
      .main-header-info {
        flex: 1;
      }
      .main-header-info h2 {
        font-size: 24px;
        font-weight: 600;
        color: #333;
        margin-bottom: 4px;
      }
      .main-header-info p {
        font-size: 14px;
        color: #888;
      }
      .progress-bar {
        margin-top: 10px;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
        width: 300px;
      }
      .progress-bar-fill {
        height: 100%;
        background: #4caf50;
        transition: width 0.3s;
      }

      /* Parts Grid */
      .parts-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 10px;
      }
      .progress-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-top: 4px;
        font-size: 12px;
      }
      .filter-controls {
        display: flex;
        gap: 16px;
      }
      .filter-controls label {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        cursor: pointer;
      }
      .filter-controls input[type="checkbox"] {
        width: 14px;
        height: 14px;
        cursor: pointer;
      }
      .part-card {
        background: #fff;
        border-radius: 8px;
        box-shadow: 0 1px 4px rgba(0,0,0,0.1);
        overflow: hidden;
        transition: opacity 0.5s;
        display: flex;
        flex-direction: column;
      }
      .part-card-body {
        display: flex;
        align-items: stretch;
      }
      .part-card.fade-out {
        opacity: 0;
      }
      .part-card.hidden {
        display: none;
      }
      .part-card.complete {
        background: #555;
      }
      .part-card.complete .part-card-image {
        background: #444;
      }
      .part-card.complete .part-card-image img {
        opacity: 0.5;
      }
      .part-card.complete .part-card-info {
        background: #555;
      }
      .part-card.complete .part-card-info h4,
      .part-card.complete .part-card-controls span {
        color: #ccc;
      }
      .part-card.complete .part-card-color {
        background: #666 !important;
      }
      .part-card-image {
        position: relative;
        width: 80px;
        height: 80px;
        min-width: 80px;
        background: #f9f9f9;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .part-card-image img {
        max-width: 70px;
        max-height: 70px;
        object-fit: contain;
      }
      .part-card-image a {
        display: contents;
      }
      .part-card-checkmark {
        position: absolute;
        top: 4px;
        right: 4px;
        width: 18px;
        height: 18px;
        background: #4caf50;
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 12px;
        font-weight: bold;
      }
      .part-card.complete .part-card-checkmark {
        display: flex;
      }
      .part-card-info {
        flex: 1;
        padding: 8px 12px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        min-width: 0;
      }
      .part-card-info h4 {
        font-size: 12px;
        font-weight: 500;
        color: #333;
        margin-bottom: 4px;
        line-height: 1.3;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }
      .part-card-controls {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 8px;
      }
      .part-card-controls span {
        font-size: 14px;
        font-weight: 600;
        color: #666;
      }
      .part-card-buttons {
        display: flex;
        gap: 4px;
      }
      .part-card-buttons button {
        width: 24px;
        height: 24px;
        border: none;
        border-radius: 4px;
        background: #e0e0e0;
        color: #333;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        transition: background 0.2s;
      }
      .part-card-buttons button:hover {
        background: #d0d0d0;
      }
      .part-card-buttons button:active {
        background: #c0c0c0;
      }
      .part-card-color {
        padding: 4px 10px;
        font-size: 10px;
        font-weight: 600;
        text-align: center;
        color: #fff;
      }

      /* Empty state */
      .empty-state {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 300px;
        color: #888;
        font-size: 16px;
      }

      /* Compact mode */
      .parts-grid.compact {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      }
      .compact .part-card-info h4 {
        display: none;
      }
      .compact .part-card-body {
        flex-direction: column;
      }
      .compact .part-card-image {
        width: 100%;
        height: 70px;
      }
      .compact .part-card-info {
        padding: 6px 8px;
      }
      .compact .part-card-controls {
        justify-content: center;
      }
      .compact .part-card-controls span {
        font-size: 11px;
      }
      .compact .part-card-buttons button {
        width: 20px;
        height: 20px;
        font-size: 12px;
      }

      footer {
        position: fixed;
        bottom: 0;
        right: 0;
        padding: 8px 16px;
        font-size: 11px;
        color: #666;
        background: rgba(245, 245, 245, 0.95);
        border-radius: 8px 0 0 0;
      }
      footer a {
        color: #888;
      }

      @media print {
        .sidebar {
          display: none;
        }
        .layout {
          grid-template-columns: 1fr;
        }
        footer {
          display: none;
        }
        .part-card-color {
          -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
        }
        .part-card-buttons {
          display: none;
        }
        .part-card {
          break-inside: avoid;
        }
        .filter-controls {
          display: none;
        }
        .parts-grid.compact {
          grid-template-columns: repeat(8, 1fr);
        }
        .compact .part-card-image {
          height: 50px;
        }
        .compact .part-card-image img {
          max-width: 45px;
          max-height: 45px;
        }
        .compact .part-card-info {
          padding: 4px 6px;
        }
        .compact .part-card-controls span {
          font-size: 9px;
        }
        .compact .part-card-color {
          padding: 2px 4px;
          font-size: 8px;
        }
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <aside class="sidebar">
        <div class="sidebar-header">
          <h1>Set Inventory</h1>
        </div>
        <ul class="set-list" id="set-list"></ul>
      </aside>

      <main class="main">
        <div class="main-header" id="main-header">
          <div class="empty-state">Select a set from the sidebar</div>
        </div>
        <div class="parts-grid" id="parts-grid"></div>
      </main>
    </div>
    <footer>&copy; 2026 William Kapke &bull; Data provided by <a href="https://www.bricklink.com" target="_blank">Bricklink</a></footer>

    <script>
      const STORAGE_KEY = "lego_inventory";
      let inventory = {};
      let userData = {};
      let selectedSetId = null;
      let colors = {};
      let pendingFadeOuts = new Map(); // partKey -> timeoutId

      function loadUserData() {
        try {
          const stored = localStorage.getItem(STORAGE_KEY);
          userData = stored ? JSON.parse(stored) : {};
        } catch {
          userData = {};
        }
      }

      function saveUserData() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(userData));
      }

      function getPartKey(part) {
        return part.colorId ? `${part.partNum}_${part.colorId}` : part.partNum;
      }

      function isLightColor(hex) {
        if (!hex) return false;
        const rgb = parseInt(hex.slice(1), 16);
        const r = (rgb >> 16) & 0xff;
        const g = (rgb >> 8) & 0xff;
        const b = rgb & 0xff;
        // Calculate luminance
        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        return luminance > 0.6;
      }

      function getHaveCount(setId, partKey) {
        return userData[setId]?.parts?.[partKey]?.have || 0;
      }

      function setHaveCount(setId, partKey, count) {
        if (!userData[setId]) {
          userData[setId] = { parts: {} };
        }
        if (!userData[setId].parts) {
          userData[setId].parts = {};
        }
        userData[setId].parts[partKey] = { have: count };
        saveUserData();
      }

      async function init() {
        loadUserData();

        const [inventoryRes, colorsRes] = await Promise.all([
          fetch("set-inventory.json"),
          fetch("bricklink-colors.json"),
        ]);
        inventory = await inventoryRes.json();
        colors = await colorsRes.json();

        renderSetList();

        // Restore last selected or pick first
        const lastSet = localStorage.getItem("lastInventorySet");
        const setIds = Object.keys(inventory);
        if (lastSet && inventory[lastSet]) {
          selectSet(lastSet);
        } else if (setIds.length > 0) {
          selectSet(setIds[0]);
        }
      }

      function renderSetList() {
        const list = document.getElementById("set-list");
        const setIds = Object.keys(inventory);

        list.innerHTML = setIds.map((setId) => {
          const set = inventory[setId];
          return `
            <li class="set-item ${selectedSetId === setId ? 'active' : ''}" data-set-id="${setId}">
              <img src="${set.image}" alt="">
              <div class="set-item-info">
                <h3>${set.name}</h3>
                <span>${setId}</span>
              </div>
            </li>
          `;
        }).join("");

        list.querySelectorAll(".set-item").forEach((el) => {
          el.addEventListener("click", () => {
            selectSet(el.dataset.setId);
          });
        });
      }

      function selectSet(setId) {
        selectedSetId = setId;
        localStorage.setItem("lastInventorySet", setId);

        // Clear any pending fade-outs
        pendingFadeOuts.forEach((timeoutId) => clearTimeout(timeoutId));
        pendingFadeOuts.clear();

        // Update sidebar active state
        document.querySelectorAll(".set-item").forEach((el) => {
          el.classList.toggle("active", el.dataset.setId === setId);
        });

        renderMainContent();
      }

      function calculateProgress(setId) {
        const set = inventory[setId];
        if (!set) return { complete: 0, total: 0 };

        let complete = 0;
        let total = 0;

        for (const part of set.parts) {
          const needed = parseInt(part.quantity) || 1;
          const have = getHaveCount(setId, getPartKey(part));
          total += needed;
          complete += Math.min(have, needed);
        }

        return { complete, total };
      }

      function renderMainContent() {
        const set = inventory[selectedSetId];
        if (!set) return;

        const { complete, total } = calculateProgress(selectedSetId);
        const pct = total > 0 ? Math.round((complete / total) * 100) : 0;

        const header = document.getElementById("main-header");
        header.innerHTML = `
          <img src="${set.image}" alt="">
          <div class="main-header-info">
            <h2>${set.name}</h2>
            <p>${selectedSetId} &bull; ${set.parts.length} unique parts</p>
            <div class="progress-bar">
              <div class="progress-bar-fill" style="width: ${pct}%"></div>
            </div>
            <div class="progress-row">
              <p>${complete} / ${total} parts (${pct}%)</p>
              <div class="filter-controls" id="filter-controls">
                <label><input type="checkbox" id="filter-complete" checked> Complete</label>
                <label><input type="checkbox" id="filter-incomplete" checked> Not Complete</label>
                <label><input type="checkbox" id="filter-compact"> Compact</label>
              </div>
            </div>
          </div>
        `;

        // Restore filter state from URL params
        const params = new URLSearchParams(window.location.search);
        const completeParam = params.get("complete");
        const incompleteParam = params.get("incomplete");
        const compactParam = params.get("compact");
        document.getElementById("filter-complete").checked = completeParam !== "0";
        document.getElementById("filter-incomplete").checked = incompleteParam !== "0";
        document.getElementById("filter-compact").checked = compactParam === "1";

        // Re-attach filter checkbox listeners
        document.getElementById("filter-complete").addEventListener("change", applyFilters);
        document.getElementById("filter-incomplete").addEventListener("change", applyFilters);
        document.getElementById("filter-compact").addEventListener("change", applyFilters);

        renderPartsGrid();
      }

      function renderPartsGrid() {
        const set = inventory[selectedSetId];
        const grid = document.getElementById("parts-grid");

        // Sort parts by color name, then by part number
        const sortedParts = [...set.parts].sort((a, b) => {
          const colorA = colors[a.colorId]?.name || "Unknown";
          const colorB = colors[b.colorId]?.name || "Unknown";
          const colorCmp = colorA.localeCompare(colorB);
          if (colorCmp !== 0) return colorCmp;
          return a.partNum.localeCompare(b.partNum);
        });

        grid.innerHTML = sortedParts.map((part) => {
          const partKey = getPartKey(part);
          const needed = parseInt(part.quantity) || 1;
          const have = getHaveCount(selectedSetId, partKey);
          const isComplete = have >= needed;

          const color = colors[part.colorId] || { name: "Unknown", rgb: "#888" };
          const textColor = isLightColor(color.rgb) ? "#333" : "#fff";

          return `
            <div class="part-card ${isComplete ? 'complete' : ''}" data-part-key="${partKey}" data-needed="${needed}">
              <div class="part-card-color" style="background: ${color.rgb || '#888'}; color: ${textColor};">
                ${color.name}
              </div>
              <div class="part-card-body">
                <div class="part-card-image">
                  <a href="${part.partUrl}" target="_blank">
                    <img src="${part.thumbnail}" alt="${part.description}">
                  </a>
                  <div class="part-card-checkmark">&#10003;</div>
                </div>
                <div class="part-card-info">
                  <h4>${part.description || part.partNum}</h4>
                  <div class="part-card-controls">
                    <span>Have ${have} of ${needed}</span>
                    <div class="part-card-buttons">
                      <button class="btn-minus" data-part-key="${partKey}">-</button>
                      <button class="btn-plus" data-part-key="${partKey}">+</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          `;
        }).join("");

        // Add event listeners
        grid.querySelectorAll(".btn-plus").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const partKey = btn.dataset.partKey;
            const current = getHaveCount(selectedSetId, partKey);
            const newCount = current + 1;
            setHaveCount(selectedSetId, partKey, newCount);
            updateCardState(partKey, newCount);
          });
        });

        grid.querySelectorAll(".btn-minus").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const partKey = btn.dataset.partKey;
            const current = getHaveCount(selectedSetId, partKey);
            if (current > 0) {
              const newCount = current - 1;
              setHaveCount(selectedSetId, partKey, newCount);
              updateCardState(partKey, newCount);
            }
          });
        });

        applyFilters();
      }

      function updateCardState(partKey, newCount) {
        const card = document.querySelector(`.part-card[data-part-key="${partKey}"]`);
        if (!card) return;

        const needed = parseInt(card.dataset.needed) || 1;
        const wasComplete = card.classList.contains("complete");
        const isNowComplete = newCount >= needed;
        const showComplete = document.getElementById("filter-complete").checked;

        // Update the card's visual state
        card.classList.toggle("complete", isNowComplete);

        // Update the have count display
        const countSpan = card.querySelector(".part-card-controls span");
        if (countSpan) {
          const isCompact = document.getElementById("filter-compact")?.checked;
          countSpan.textContent = isCompact ? `${newCount} of ${needed}` : `Have ${newCount} of ${needed}`;
        }

        // Update progress bar
        updateProgressBar();

        // Clear any pending fade-out for this card
        if (pendingFadeOuts.has(partKey)) {
          clearTimeout(pendingFadeOuts.get(partKey));
          pendingFadeOuts.delete(partKey);
          card.classList.remove("fade-out");
        }

        // Handle delayed fade-out when becoming complete and complete filter is off
        if (!wasComplete && isNowComplete && !showComplete) {
          const timeoutId = setTimeout(() => {
            card.classList.add("fade-out");
            setTimeout(() => {
              card.classList.add("hidden");
              pendingFadeOuts.delete(partKey);
            }, 500);
          }, 1000);
          pendingFadeOuts.set(partKey, timeoutId);
        }

        // Handle showing card when becoming incomplete
        if (wasComplete && !isNowComplete) {
          card.classList.remove("fade-out", "hidden");
        }
      }

      function updateProgressBar() {
        const { complete, total } = calculateProgress(selectedSetId);
        const pct = total > 0 ? Math.round((complete / total) * 100) : 0;
        const progressFill = document.querySelector(".progress-bar-fill");
        const progressText = document.querySelector(".main-header-info p:last-child");
        if (progressFill) progressFill.style.width = `${pct}%`;
        if (progressText) progressText.textContent = `${complete} / ${total} parts (${pct}%)`;
      }

      function applyFilters() {
        const showComplete = document.getElementById("filter-complete").checked;
        const showIncomplete = document.getElementById("filter-incomplete").checked;
        const isCompact = document.getElementById("filter-compact").checked;

        // Update URL params
        const params = new URLSearchParams(window.location.search);
        params.set("complete", showComplete ? "1" : "0");
        params.set("incomplete", showIncomplete ? "1" : "0");
        params.set("compact", isCompact ? "1" : "0");
        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState({}, "", newUrl);

        // Toggle compact mode on grid
        document.getElementById("parts-grid").classList.toggle("compact", isCompact);

        // Update count display format based on compact mode
        document.querySelectorAll(".part-card-controls span").forEach((span) => {
          const text = span.textContent;
          const match = text.match(/(\d+)\s*of\s*(\d+)/);
          if (match) {
            span.textContent = isCompact ? `${match[1]} of ${match[2]}` : `Have ${match[1]} of ${match[2]}`;
          }
        });

        // Clear any pending fade-outs
        pendingFadeOuts.forEach((timeoutId) => clearTimeout(timeoutId));
        pendingFadeOuts.clear();

        document.querySelectorAll(".part-card").forEach((card) => {
          const isComplete = card.classList.contains("complete");
          const shouldShow = (isComplete && showComplete) || (!isComplete && showIncomplete);
          card.classList.remove("fade-out");
          card.classList.toggle("hidden", !shouldShow);
        });
      }

      init();
    </script>
  </body>
</html>
