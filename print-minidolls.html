<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Print Minidolls</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #f5f5f5;
      }
      .pages {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      canvas {
        background: #fff;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        max-width: 100%;
        height: auto;
      }
    </style>
  </head>
  <body>
    <div class="pages" id="pages"></div>

    <script>
      // Grid config
      const COLS = 8;
      const ROWS = 3;
      const CELLS_PER_PAGE = COLS * ROWS;

      // Cell size in mm
      const CELL_WIDTH_MM = 32;
      const IMAGE_HEIGHT_MM = 50;
      const MICRO_HEIGHT_MM = 32;
      const BABY_HEIGHT_MM = 19;
      const HEADER_HEIGHT_MM = 6;
      const CELL_HEIGHT_MM = IMAGE_HEIGHT_MM + HEADER_HEIGHT_MM; // 56mm total

      // 300 DPI: 1 inch = 25.4mm, so pixels per mm = 300/25.4 â‰ˆ 11.811
      const DPI = 300;
      const PX_PER_MM = DPI / 25.4;

      // Cell size in pixels
      const CELL_WIDTH = Math.round(CELL_WIDTH_MM * PX_PER_MM);
      const CELL_HEIGHT = Math.round(CELL_HEIGHT_MM * PX_PER_MM);
      const HEADER_HEIGHT = Math.round(HEADER_HEIGHT_MM * PX_PER_MM);
      const IMAGE_HEIGHT = Math.round(IMAGE_HEIGHT_MM * PX_PER_MM);
      const MICRO_HEIGHT = Math.round(MICRO_HEIGHT_MM * PX_PER_MM);
      const BABY_HEIGHT = Math.round(BABY_HEIGHT_MM * PX_PER_MM);

      // Grid size
      const GRID_WIDTH = CELL_WIDTH * COLS;
      const GRID_HEIGHT = CELL_HEIGHT * ROWS;

      // Canvas size: exactly 11" x 8.5" (landscape letter) at 300 DPI
      const PAGE_WIDTH_IN = 11;
      const PAGE_HEIGHT_IN = 8.5;
      const CANVAS_WIDTH = Math.round(PAGE_WIDTH_IN * DPI);
      const CANVAS_HEIGHT = Math.round(PAGE_HEIGHT_IN * DPI);

      // Margins to center the grid
      const MARGIN_LEFT = Math.round((CANVAS_WIDTH - GRID_WIDTH) / 2);
      const MARGIN_TOP = Math.round((CANVAS_HEIGHT - GRID_HEIGHT) / 2);

      // Colors for name headers (same as bricklink.html)
      const COLORS = [
        "#e91e63", "#9c27b0", "#673ab7", "#3f51b5", "#2196f3",
        "#03a9f4", "#00bcd4", "#009688", "#4caf50", "#8bc34a",
        "#cddc39", "#ff9800", "#ff5722", "#795548", "#607d8b",
        "#f44336", "#e040fb", "#7c4dff", "#448aff", "#18ffff",
      ];

      function getColorForName(name, nameColorMap) {
        if (!nameColorMap.has(name)) {
          const colorIndex = nameColorMap.size % COLORS.length;
          nameColorMap.set(name, COLORS[colorIndex]);
        }
        return nameColorMap.get(name);
      }

      function getTargetHeight(doll) {
        const desc = doll.description.toLowerCase();
        if (desc.includes('baby')) return BABY_HEIGHT;
        if (desc.includes('micro') || desc.includes('mirco')) return MICRO_HEIGHT;
        return IMAGE_HEIGHT;
      }

      function loadImage(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = src;
        });
      }

      // Detect content bounds by finding non-background pixels
      function getContentBounds(img, threshold = 240) {
        const canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
        let edgeColors = [];

        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            const i = (y * canvas.width + x) * 4;
            const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];

            // Collect edge colors for background detection
            if (x < 5 || x >= canvas.width - 5 || y < 5 || y >= canvas.height - 5) {
              if (a > 200) {
                edgeColors.push({ r, g, b });
              }
            }

            // Check if pixel is "content" (not near-white and not transparent)
            const isWhitish = r > threshold && g > threshold && b > threshold;
            const isTransparent = a < 50;

            if (!isWhitish && !isTransparent) {
              if (x < minX) minX = x;
              if (x > maxX) maxX = x;
              if (y < minY) minY = y;
              if (y > maxY) maxY = y;
            }
          }
        }

        // Calculate average edge color for background
        let avgR = 255, avgG = 255, avgB = 255;
        if (edgeColors.length > 0) {
          avgR = Math.round(edgeColors.reduce((s, c) => s + c.r, 0) / edgeColors.length);
          avgG = Math.round(edgeColors.reduce((s, c) => s + c.g, 0) / edgeColors.length);
          avgB = Math.round(edgeColors.reduce((s, c) => s + c.b, 0) / edgeColors.length);
        }

        // Add small padding
        const padding = 5;
        minX = Math.max(0, minX - padding);
        minY = Math.max(0, minY - padding);
        maxX = Math.min(canvas.width - 1, maxX + padding);
        maxY = Math.min(canvas.height - 1, maxY + padding);

        return {
          x: minX,
          y: minY,
          width: maxX - minX + 1,
          height: maxY - minY + 1,
          bgColor: `rgb(${avgR}, ${avgG}, ${avgB})`
        };
      }

      async function createPageCanvas(dolls, nameColorMap) {
        const canvas = document.createElement("canvas");
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        const ctx = canvas.getContext("2d");

        // White background
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        for (let i = 0; i < dolls.length; i++) {
          const doll = dolls[i];
          const col = i % COLS;
          const row = Math.floor(i / COLS);

          const cellX = MARGIN_LEFT + col * CELL_WIDTH;
          const cellY = MARGIN_TOP + row * CELL_HEIGHT;
          const imageY = cellY + HEADER_HEIGHT;

          const name = doll.name || doll.id;
          const headerColor = getColorForName(name, nameColorMap);

          // Draw name header
          ctx.fillStyle = headerColor;
          ctx.fillRect(cellX, cellY, CELL_WIDTH, HEADER_HEIGHT);

          // Draw name text
          ctx.fillStyle = "#ffffff";
          ctx.font = `bold ${Math.round(HEADER_HEIGHT * 0.65)}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(name, cellX + CELL_WIDTH / 2, cellY + HEADER_HEIGHT / 2, CELL_WIDTH - 10);

          try {
            const img = await loadImage(doll.image);

            // Get content bounds and background color
            const bounds = getContentBounds(img);

            // Fill image area with detected background color for seamless look
            ctx.fillStyle = bounds.bgColor;
            ctx.fillRect(cellX, imageY, CELL_WIDTH, IMAGE_HEIGHT);

            // Use smaller area for micro/baby dolls (bottom-aligned)
            const targetHeight = getTargetHeight(doll);

            // Scale cropped content to fit image area while maintaining aspect ratio
            const scale = Math.min(
              CELL_WIDTH / bounds.width,
              targetHeight / bounds.height
            );
            const drawWidth = bounds.width * scale;
            const drawHeight = bounds.height * scale;

            // Center horizontally, position at bottom for smaller dolls, center for normal
            const drawX = cellX + (CELL_WIDTH - drawWidth) / 2;
            const drawY = targetHeight < IMAGE_HEIGHT
              ? imageY + IMAGE_HEIGHT - drawHeight  // Bottom-aligned for smaller dolls
              : imageY + (IMAGE_HEIGHT - drawHeight) / 2;  // Centered for normal

            // Draw only the cropped portion
            ctx.drawImage(
              img,
              bounds.x, bounds.y, bounds.width, bounds.height,
              drawX, drawY, drawWidth, drawHeight
            );
          } catch (e) {
            console.error(`Failed to load image for ${doll.id}:`, e);
          }
        }

        // Draw vertical grid lines on top
        ctx.strokeStyle = "#cccccc";
        ctx.lineWidth = 1;
        for (let col = 1; col < COLS; col++) {
          const x = MARGIN_LEFT + col * CELL_WIDTH;
          ctx.beginPath();
          ctx.moveTo(x, MARGIN_TOP);
          ctx.lineTo(x, MARGIN_TOP + GRID_HEIGHT);
          ctx.stroke();
        }

        return canvas;
      }

      async function init() {
        const res = await fetch("minidolls.bricklink.json");
        const minidolls = await res.json();

        // Filter: owned only
        const filtered = minidolls.filter(doll => doll.owned);

        // Sort by name (same as bricklink.html)
        filtered.sort((a, b) => {
          const nameA = (a.name || a.id).toLowerCase();
          const nameB = (b.name || b.id).toLowerCase();
          return nameA.localeCompare(nameB);
        });

        const pageCount = Math.ceil(filtered.length / CELLS_PER_PAGE);
        const pagesEl = document.getElementById("pages");
        const nameColorMap = new Map();

        for (let p = 0; p < pageCount; p++) {
          const start = p * CELLS_PER_PAGE;
          const pageDolls = filtered.slice(start, start + CELLS_PER_PAGE);

          const canvas = await createPageCanvas(pageDolls, nameColorMap);
          pagesEl.appendChild(canvas);
        }
      }

      init();
    </script>
  </body>
</html>
