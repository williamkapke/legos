<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Print Minidolls</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #f5f5f5;
      }
      .pages {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      canvas {
        background: #fff;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        max-width: 100%;
        height: auto;
      }
    </style>
  </head>
  <body>
    <div class="pages" id="pages"></div>

    <script>
      // Grid config
      const COLS = 8;
      const ROWS = 3;
      const CELLS_PER_PAGE = COLS * ROWS;

      // Cell size in mm
      const CELL_WIDTH_MM = 32;
      const IMAGE_HEIGHT_MM = 50;
      const MICRO_HEIGHT_MM = 32;
      const BABY_HEIGHT_MM = 19;
      const HEADER_HEIGHT_MM = 6;
      const CELL_HEIGHT_MM = IMAGE_HEIGHT_MM + HEADER_HEIGHT_MM; // 56mm total

      // 300 DPI: 1 inch = 25.4mm, so pixels per mm = 300/25.4 â‰ˆ 11.811
      const DPI = 300;
      const PX_PER_MM = DPI / 25.4;

      // Cell size in pixels
      const CELL_WIDTH = Math.round(CELL_WIDTH_MM * PX_PER_MM);
      const CELL_HEIGHT = Math.round(CELL_HEIGHT_MM * PX_PER_MM);
      const HEADER_HEIGHT = Math.round(HEADER_HEIGHT_MM * PX_PER_MM);
      const IMAGE_HEIGHT = Math.round(IMAGE_HEIGHT_MM * PX_PER_MM);
      const MICRO_HEIGHT = Math.round(MICRO_HEIGHT_MM * PX_PER_MM);
      const BABY_HEIGHT = Math.round(BABY_HEIGHT_MM * PX_PER_MM);

      // Grid size
      const GRID_WIDTH = CELL_WIDTH * COLS;
      const GRID_HEIGHT = CELL_HEIGHT * ROWS;

      // Canvas size: exactly 11" x 8.5" (landscape letter) at 300 DPI
      const PAGE_WIDTH_IN = 11;
      const PAGE_HEIGHT_IN = 8.5;
      const CANVAS_WIDTH = Math.round(PAGE_WIDTH_IN * DPI);
      const CANVAS_HEIGHT = Math.round(PAGE_HEIGHT_IN * DPI);

      // Margins to center the grid
      const MARGIN_LEFT = Math.round((CANVAS_WIDTH - GRID_WIDTH) / 2);
      const MARGIN_TOP = Math.round((CANVAS_HEIGHT - GRID_HEIGHT) / 2);

      // Colors for name headers (same as bricklink.html)
      const COLORS = [
        "#e91e63", "#9c27b0", "#673ab7", "#3f51b5", "#2196f3",
        "#03a9f4", "#00bcd4", "#009688", "#4caf50", "#8bc34a",
        "#cddc39", "#ff9800", "#ff5722", "#795548", "#607d8b",
        "#f44336", "#e040fb", "#7c4dff", "#448aff", "#18ffff",
      ];

      function getColorForName(name, nameColorMap) {
        if (!nameColorMap.has(name)) {
          const colorIndex = nameColorMap.size % COLORS.length;
          nameColorMap.set(name, COLORS[colorIndex]);
        }
        return nameColorMap.get(name);
      }

      function getTargetHeight(doll) {
        const desc = doll.description.toLowerCase();
        if (desc.includes('baby')) return BABY_HEIGHT;
        if (desc.includes('micro') || desc.includes('mirco')) return MICRO_HEIGHT;
        return IMAGE_HEIGHT;
      }

      function loadImage(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = src;
        });
      }

      // Detect content bounds by finding non-background pixels
      function getContentBounds(img, colorThreshold = 75) {
        const canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        // First pass: collect corner colors to detect background (corners are most reliable)
        let edgeColors = [];
        const cornerSize = 20;
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            const inTopLeft = x < cornerSize && y < cornerSize;
            const inTopRight = x >= canvas.width - cornerSize && y < cornerSize;
            const inBottomLeft = x < cornerSize && y >= canvas.height - cornerSize;
            const inBottomRight = x >= canvas.width - cornerSize && y >= canvas.height - cornerSize;
            if (inTopLeft || inTopRight || inBottomLeft || inBottomRight) {
              const i = (y * canvas.width + x) * 4;
              const a = data[i + 3];
              if (a > 200) {
                edgeColors.push({ r: data[i], g: data[i + 1], b: data[i + 2] });
              }
            }
          }
        }

        // Use the lightest corner pixels as background reference (shadows are darker)
        let bgR = 255, bgG = 255, bgB = 255;
        if (edgeColors.length > 0) {
          // Sort by brightness and take the 90th percentile to avoid outliers
          edgeColors.sort((a, b) => (b.r + b.g + b.b) - (a.r + a.g + a.b));
          const idx = Math.floor(edgeColors.length * 0.1); // top 10% lightest
          const light = edgeColors.slice(0, Math.max(1, idx));
          bgR = Math.round(light.reduce((s, c) => s + c.r, 0) / light.length);
          bgG = Math.round(light.reduce((s, c) => s + c.g, 0) / light.length);
          bgB = Math.round(light.reduce((s, c) => s + c.b, 0) / light.length);
        }

        // Helper to check if pixel is content
        const isContent = (x, y) => {
          const i = (y * canvas.width + x) * 4;
          const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];
          if (a < 50) return false;
          const colorDiff = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
          return colorDiff >= colorThreshold;
        };

        // Find all four bounds independently
        let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            if (isContent(x, y)) {
              if (x < minX) minX = x;
              if (x > maxX) maxX = x;
              if (y < minY) minY = y;
              if (y > maxY) maxY = y;
            }
          }
        }

        // Make horizontal bounds symmetric (use larger margin to crop out shadows)
        const leftMargin = minX;
        const rightMargin = canvas.width - 1 - maxX;
        const maxMargin = Math.max(leftMargin, rightMargin);
        minX = maxMargin;
        maxX = canvas.width - 1 - maxMargin;

        // Add small padding
        const padding = 5;
        minX = Math.max(0, minX - padding);
        minY = Math.max(0, minY - padding);
        maxX = Math.min(canvas.width - 1, maxX + padding);
        maxY = Math.min(canvas.height - 1, maxY + padding);

        return {
          x: minX,
          y: minY,
          width: maxX - minX + 1,
          height: maxY - minY + 1,
          bgColor: `rgb(${bgR}, ${bgG}, ${bgB})`
        };
      }

      async function createPageCanvas(dolls, nameColorMap) {
        const canvas = document.createElement("canvas");
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        const ctx = canvas.getContext("2d");

        // White background
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw cutting guides (before content so headers can overlap)
        ctx.strokeStyle = "#999999";
        ctx.lineWidth = 1;

        // Horizontal lines between rows (1px below row top so header overlaps most of it)
        for (let row = 0; row <= ROWS; row++) {
          const y = MARGIN_TOP + row * CELL_HEIGHT + 1;
          ctx.beginPath();
          ctx.moveTo(MARGIN_LEFT, y);
          ctx.lineTo(MARGIN_LEFT + GRID_WIDTH, y);
          ctx.stroke();
        }

        // Left and right borders
        ctx.beginPath();
        ctx.moveTo(MARGIN_LEFT, MARGIN_TOP);
        ctx.lineTo(MARGIN_LEFT, MARGIN_TOP + GRID_HEIGHT);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(MARGIN_LEFT + GRID_WIDTH, MARGIN_TOP);
        ctx.lineTo(MARGIN_LEFT + GRID_WIDTH, MARGIN_TOP + GRID_HEIGHT);
        ctx.stroke();

        for (let i = 0; i < dolls.length; i++) {
          const doll = dolls[i];
          const col = i % COLS;
          const row = Math.floor(i / COLS);

          const cellX = MARGIN_LEFT + col * CELL_WIDTH;
          const cellY = MARGIN_TOP + row * CELL_HEIGHT;
          const imageY = cellY + HEADER_HEIGHT;

          const name = doll.name || doll.id;
          const headerColor = getColorForName(name, nameColorMap);

          // Draw name header
          ctx.fillStyle = headerColor;
          ctx.fillRect(cellX, cellY, CELL_WIDTH, HEADER_HEIGHT);

          // Draw name text
          ctx.fillStyle = "#ffffff";
          ctx.font = `bold ${Math.round(HEADER_HEIGHT * 0.65)}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(name, cellX + CELL_WIDTH / 2, cellY + HEADER_HEIGHT / 2, CELL_WIDTH - 10);

          try {
            const img = await loadImage(doll.image);

            // Get content bounds and background color
            const bounds = getContentBounds(img);

            // Fill image area with detected background color for seamless look
            ctx.fillStyle = bounds.bgColor;
            ctx.fillRect(cellX, imageY, CELL_WIDTH, IMAGE_HEIGHT);

            // Use smaller area for micro/baby dolls (bottom-aligned)
            const targetHeight = getTargetHeight(doll);

            // Scale cropped content to fit image area while maintaining aspect ratio
            const scale = Math.min(
              CELL_WIDTH / bounds.width,
              targetHeight / bounds.height
            );
            const drawWidth = bounds.width * scale;
            const drawHeight = bounds.height * scale;

            // Center horizontally, position at bottom for smaller dolls, center for normal
            const drawX = cellX + (CELL_WIDTH - drawWidth) / 2;
            const drawY = targetHeight < IMAGE_HEIGHT
              ? imageY + IMAGE_HEIGHT - drawHeight  // Bottom-aligned for smaller dolls
              : imageY + (IMAGE_HEIGHT - drawHeight) / 2;  // Centered for normal

            // Draw only the cropped portion
            ctx.drawImage(
              img,
              bounds.x, bounds.y, bounds.width, bounds.height,
              drawX, drawY, drawWidth, drawHeight
            );
          } catch (e) {
            console.error(`Failed to load image for ${doll.id}:`, e);
          }
        }

        // Draw vertical grid lines on top
        ctx.strokeStyle = "#999999";
        ctx.lineWidth = 1;
        for (let col = 1; col < COLS; col++) {
          const x = MARGIN_LEFT + col * CELL_WIDTH;
          ctx.beginPath();
          ctx.moveTo(x, MARGIN_TOP);
          ctx.lineTo(x, MARGIN_TOP + GRID_HEIGHT);
          ctx.stroke();
        }

        return canvas;
      }

      async function init() {
        const res = await fetch("minidolls.bricklink.json");
        const minidolls = await res.json();

        // Check for ids query parameter
        const params = new URLSearchParams(window.location.search);
        const idsParam = params.get("ids");

        let filtered;
        if (idsParam) {
          // Use specified IDs in order
          const ids = idsParam.split(",").map(id => id.trim());
          const dollMap = new Map(minidolls.map(d => [d.id, d]));
          filtered = ids.map(id => dollMap.get(id)).filter(Boolean);
        } else {
          // Default: owned only, sorted by name
          filtered = minidolls.filter(doll => doll.owned);
          filtered.sort((a, b) => {
            const nameA = (a.name || a.id).toLowerCase();
            const nameB = (b.name || b.id).toLowerCase();
            return nameA.localeCompare(nameB);
          });
        }

        const pageCount = Math.ceil(filtered.length / CELLS_PER_PAGE);
        const pagesEl = document.getElementById("pages");
        const nameColorMap = new Map();

        for (let p = 0; p < pageCount; p++) {
          const start = p * CELLS_PER_PAGE;
          const pageDolls = filtered.slice(start, start + CELLS_PER_PAGE);

          const canvas = await createPageCanvas(pageDolls, nameColorMap);
          pagesEl.appendChild(canvas);
        }
      }

      init();
    </script>
  </body>
</html>
